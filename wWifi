#include <WiFi.h>
#include <WiFiUdp.h>
#include <NTPClient.h>
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BNO055.h>
#include <Adafruit_AS7341.h>
#include <utility/imumaths.h>

// Wi-Fi credentials
const char* ssid = "Wifi_Tara_Scientist";       // Your WiFi SSID
const char* password = "Tara@Scientist2023";    // Your WiFi password

WiFiServer server(4069); // create a server on port 69

// Set up NTP
WiFiUDP udp;
NTPClient timeClient(udp, "pool.ntp.org", 0, 3600000);  // UTC, update every 1 hour


// Initialize sensors
Adafruit_BNO055 bno = Adafruit_BNO055(55, 0x28, &Wire);
Adafruit_AS7341 sensors[3]; 
#define MUX_ADDR 0x70  // default I2C address for PCA9546A

void selectMuxChannel(uint8_t channel) {
  if (channel > 3) return;  // only 0-3 valid
  Wire.beginTransmission(MUX_ADDR);
  Wire.write(1 << channel);  // pick channel
  Wire.endTransmission();
}

void setup() {
  // Start serial communication
  Serial.begin(115200);
  while (!Serial) delay(10);  // wait for serial port to open!

  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi! IP Address: ");
  Serial.println(WiFi.localIP());

  // Start the server
  server.begin();
  
  // Initialize sensors
  Wire.begin();
  selectMuxChannel(0);
  if (!bno.begin()) {
    Serial.println("Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!");
    while (1);
  }

  // Initialize the AS7341 sensors
  for (int i = 0; i < 3; i++) {
    selectMuxChannel(i + 1);
    if (!sensors[i].begin()) {
      Serial.print("Spectral sensor on channel ");
      Serial.print(i + 1);
      Serial.println(" not found!");
    } else {
      Serial.print("Spectral sensor on channel ");
      Serial.print(i + 1);
      Serial.println(" initialized.");
    }
  }
  // Configure AS7341 integration params
  //The total integration time is equal to T_int = (ð´ð‘‡ð¼ð‘€ð¸ + 1) Ã— (ð´ð‘†ð‘‡ð¸ð‘ƒ + 1) Ã— 2.78Î¼ð‘  ||| if you do the math the maximum integration time is ~46 seconds at max ATIME and ASTEP
  for (int i = 0; i < 3; i++) {
    selectMuxChannel(i + 1);
    sensors[i].setATIME(255); //0 - 255max, the integration time PER STEP in incraments of 2.78us. So, at ATIME = 1, we can assume each step takes in light for 2.78us, at 255, each step is ~ 709us (still very short)
                              // for reference ~5.4us is the time it takes light to travel one mile in a vacuum. 
    sensors[i].setASTEP(1);   //ASTEP 999 = 2.78ms (0 min - 65534 is max value, corresponds to 182ms) This is the number of integration steps...

    sensors[i].setGain(AS7341_GAIN_16X); //gain options: 0.5, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512
}
  Serial.println("Sensors initialized.");
  Serial.print("Time | Orient X (Heading) | Orient Y (Roll) | Orient Z (Pitch) | Gyro X | Gyro Y | Gyro Z | Velocity X | Velocity Y | Velocity Z |"
               "Mag X | Mag Y | Mag Z | Accel X | Accel Y | Accel Z | Grav X | Grav Y | Grav Z | Temp | Cal System | Cal Gyro | Cal Accel | Cal Grav |"
               "Spec Sensor 1 | 415 | 445 | 480 | 515 | 555 | 590 | 630 | 680 | 910 | Si Photodiode | Si Photodiode FLKR | ? | ASTEP | ATIME | GAIN |"
               "Spec Sensor 2 | 415 | 445 | 480 | 515 | 555 | 590 | 630 | 680 | 910 | Si Photodiode | Si Photodiode FLKR | ? | ASTEP | ATIME | GAIN |"
               "Spec Sensor 3 | 415 | 445 | 480 | 515 | 555 | 590 | 630 | 680 | 910 | Si Photodiode | Si Photodiode FLKR | ? | ASTEP | ATIME | GAIN ");
               


  // Initialize NTP client
  timeClient.begin();
  timeClient.update();
}

void loop() {
  // Check for incoming clients
  WiFiClient client = server.available();
  if (client) {
    Serial.println("Client connected!");

    // Keep the connection open as long as the client is connected
    while (client.connected()) {

      // ------------------ Log Time ------------------
        timeClient.update();
  
      // Get UTC time (in seconds)
        unsigned long epochTime = timeClient.getEpochTime();
  
      // Print UTC time to the client
        client.print(epochTime);  // Prints the time in seconds since 1970-01-01
        client.print(", ");

      // ------------------ IMU ------------------
      selectMuxChannel(0);

      sensors_event_t orientationData, angVelocityData, linearAccelData, magnetometerData, accelerometerData, gravityData;
      bno.getEvent(&orientationData, Adafruit_BNO055::VECTOR_EULER);
      bno.getEvent(&angVelocityData, Adafruit_BNO055::VECTOR_GYROSCOPE);
      bno.getEvent(&linearAccelData, Adafruit_BNO055::VECTOR_LINEARACCEL);
      bno.getEvent(&magnetometerData, Adafruit_BNO055::VECTOR_MAGNETOMETER);
      bno.getEvent(&accelerometerData, Adafruit_BNO055::VECTOR_ACCELEROMETER);
      bno.getEvent(&gravityData, Adafruit_BNO055::VECTOR_GRAVITY);

      printEvent(&orientationData, client);
      printEvent(&angVelocityData, client);
      printEvent(&linearAccelData, client);
      printEvent(&magnetometerData, client);
      printEvent(&accelerometerData, client);
      printEvent(&gravityData, client);

      int8_t boardTemp = bno.getTemp();
      //client.println();
      //client.print(F("Temperature: "));
      client.print(boardTemp);
      client.print(", ");

      uint8_t system, gyro, accel, mag = 0;
      bno.getCalibration(&system, &gyro, &accel, &mag);
      //Serial.println();
      //Serial.print("Calibration: Sys=");
      client.print(system);
      client.print(", ");
      //Serial.print(" Gyro=");
      client.print(gyro);
      client.print(", ");
      //Serial.print(" Accel=");
      client.print(accel);
      client.print(", ");
      //Serial.print(" Mag=");
      client.print(mag);
      client.print(", ");


      // ------------------ Spectral Sensor ------------------
      for (int s = 0; s < 3; s++) {
        selectMuxChannel(s + 1);

      uint16_t readings[12];
      if (!sensors[s].readAllChannels(readings)) {
        Serial.print("Error reading AS7341 channels: ");
        Serial.println(s + 1);
        continue;
        }

        //client.print("Spec ");
        client.print(s + 1);
        client.print(", ");
        //client.print(" : 415, 445, 480, 515, 555, 590, 630, 680, 930");
        //client.println();
        
        for (int i = 0; i < 12; i++) {
          client.print(readings[i]);
          if (i < 11) client.print(", ");
        }
        
        const char * gainNames[] = {
          //"0.5X", "1X", "2X", "4X", "8X", "16X", "32X", "64X", "128X", "256X", "512X"
            "0.5", "1", "2", "4", "8", "16", "32", "64", "128", "256", "512"
        };

        String dataString = "";
        dataString += ", " + String(sensors[s].getASTEP()) + ", ";
        dataString += String(sensors[s].getATIME()) + ", ";
        dataString += String(gainNames[sensors[s].getGain()]);
        if (s < 2) {
          dataString += ", ";
        }
        client.print(dataString);
        
        // ---- Adaptive exposure ----
        uint16_t astep = sensors[s].getASTEP();
        as7341_gain_t gain = sensors[s].getGain();

        int checkChannels[] = {0, 1, 2, 3, 6, 7, 8, 9, 11};
        bool tooHigh = false;
        bool tooLow = false;

        for (int i = 0; i < sizeof(checkChannels) / sizeof(checkChannels[0]); i++) {
          int val = readings[checkChannels[i]];
          if (val > 60000) tooHigh = true; 
          if (val < 1000) tooLow = true;
        }

        const uint16_t ASTEP_MIN = 1;        // lower bound
        const uint16_t ASTEP_MAX = 7000;    // setting max ASTEP of 15,000 with ATIME fixed @ 255 means total read time of max 10.6s, in reality to appears closer to 20s
                                            //tests show 7000 to be ~ 10s

        const as7341_gain_t GAIN_MIN = AS7341_GAIN_0_5X; // int map 0
        const as7341_gain_t GAIN_MAX = AS7341_GAIN_512X; //int map 10

        if (tooHigh) {
          if (gain > GAIN_MIN) {
            sensors[s].setGain((as7341_gain_t)(gain - 1));
            //client.print("*Spec "); client.print(s + 1); client.println(" decreasing GAIN...*");
          } else if (astep > ASTEP_MIN) {
            sensors[s].setASTEP(max(ASTEP_MIN, (uint16_t)(astep - 2000)));
            //client.print("*Spec "); client.print(s + 1); client.println(" decreasing ASTEP...*");
          }     
        }
        else if (tooLow) {
          if (astep < ASTEP_MAX) {
            sensors[s].setASTEP(min(ASTEP_MAX, (uint16_t)(astep + 2000)));
            //client.print("*Spec "); client.print(s + 1); client.println(" increasing ASTEP...*");
          } else if (gain < GAIN_MAX) {
            sensors[s].setGain((as7341_gain_t)(gain + 1));
            //client.print("*Spec "); client.print(s + 1); client.println(" increasing GAIN...*");
          }
        }
        }
        client.println();
}}}


// write a cheatsheet and log just values for inlinino read-in
void printEvent(sensors_event_t* event, WiFiClient& client) {
  double x = -1000000, y = -1000000 , z = -1000000;

  if (event->type == SENSOR_TYPE_ACCELEROMETER) {
    //client.print("Accl:");
    x = event->acceleration.x;
    y = event->acceleration.y;
    z = event->acceleration.z;
  }
  else if (event->type == SENSOR_TYPE_ORIENTATION) {
    //client.print("Orient:");
    x = event->orientation.x;
    y = event->orientation.y;
    z = event->orientation.z;
  }
  else if (event->type == SENSOR_TYPE_MAGNETIC_FIELD) {
    //client.print("Mag:");
    x = event->magnetic.x;
    y = event->magnetic.y;
    z = event->magnetic.z;
  }
  else if (event->type == SENSOR_TYPE_GYROSCOPE) {
    //client.print("Gyro:");
    x = event->gyro.x;
    y = event->gyro.y;
    z = event->gyro.z;
  }
  else if (event->type == SENSOR_TYPE_ROTATION_VECTOR) {
    //client.print("Rot:");
    x = event->gyro.x;
    y = event->gyro.y;
    z = event->gyro.z;
  }
  else if (event->type == SENSOR_TYPE_LINEAR_ACCELERATION) {
    //client.print("Linear:");
    x = event->acceleration.x;
    y = event->acceleration.y;
    z = event->acceleration.z;
  }
  else if (event->type == SENSOR_TYPE_GRAVITY) {
    //client.print("Grav:");
    x = event->acceleration.x;
    y = event->acceleration.y;
    z = event->acceleration.z;
  }
  else {
    //client.print("Unk:");
  }

  client.print(x, 3);
  client.print(", ");
  client.print(y, 3);
  client.print(", ");
  client.print(z, 3);
  client.print(", ");
}
